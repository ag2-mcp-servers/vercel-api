# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T11:33:01+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import (
    BaseSecurity,
    HTTPBearer,
    UnsuportedSecurityStub,
)
from fastapi import Header, Path, Query, Request
from pydantic import conint, constr

from models import (
    AliasId,
    Builds1,
    Decrypt,
    Delimiter,
    Direction,
    Domain,
    EdgeConfigEdgeConfigIdGetResponse,
    EdgeConfigEdgeConfigIdItemsPatchRequest,
    EdgeConfigEdgeConfigIdItemsPatchResponse,
    EdgeConfigEdgeConfigIdPutRequest,
    EdgeConfigEdgeConfigIdPutResponse,
    EdgeConfigEdgeConfigIdTokenPostRequest,
    EdgeConfigEdgeConfigIdTokenPostResponse,
    EdgeConfigEdgeConfigIdTokensDeleteRequest,
    EdgeConfigGetResponse,
    EdgeConfigItem,
    EdgeConfigPostRequest,
    EdgeConfigPostResponse,
    EdgeConfigToken,
    Follow,
    ForceNew,
    GitForkProtection,
    Id,
    IdOrName,
    IdOrName1,
    Order,
    Production,
    Provider,
    Redirects,
    RegistrationPostRequest,
    RegistrationPostResponse,
    RegistrationVerifyGetResponse,
    Role5,
    SkipAutoDetectionConfirmation,
    StatusCode,
    Target13,
    Team,
    Type138,
    V1DeploymentsDeploymentIdChecksCheckIdGetResponse,
    V1DeploymentsDeploymentIdChecksCheckIdPatchRequest,
    V1DeploymentsDeploymentIdChecksCheckIdPatchResponse,
    V1DeploymentsDeploymentIdChecksCheckIdRerequestPostResponse,
    V1DeploymentsDeploymentIdChecksGetResponse,
    V1DeploymentsDeploymentIdChecksPostRequest,
    V1DeploymentsDeploymentIdChecksPostResponse,
    V1DomainsRecordsRecordIdPatchRequest,
    V1DomainsRecordsRecordIdPatchResponse,
    V1IntegrationsConfigurationIdGetResponse,
    V1IntegrationsConfigurationsGetResponse,
    V1IntegrationsGitNamespacesGetResponse,
    V1IntegrationsSearchRepoGetResponse,
    V1LogDrainsGetResponse,
    V1LogDrainsIdGetResponse,
    V1LogDrainsPostRequest,
    V1LogDrainsPostResponse,
    V1ProjectsIdOrNameEnvIdGetResponse,
    V1TeamsPostRequest,
    V1TeamsPostResponse,
    V1TeamsTeamIdDeleteRequest,
    V1TeamsTeamIdDeleteResponse,
    V1TeamsTeamIdInvitesInviteIdDeleteResponse,
    V1TeamsTeamIdMembersPostRequest,
    V1TeamsTeamIdMembersPostResponse,
    V1TeamsTeamIdMembersTeamsJoinPostRequest,
    V1TeamsTeamIdMembersTeamsJoinPostResponse,
    V1TeamsTeamIdMembersUidDeleteResponse,
    V1TeamsTeamIdMembersUidPatchRequest,
    V1TeamsTeamIdMembersUidPatchResponse,
    V1TeamsTeamIdRequestPostRequest,
    V1TeamsTeamIdRequestPostResponse,
    V1TeamsTeamIdRequestUserIdGetResponse,
    V1UserDeleteRequest,
    V1UserDeleteResponse,
    V1WebhooksGetResponse,
    V1WebhooksIdGetResponse,
    V1WebhooksPostRequest,
    V1WebhooksPostResponse,
    V2AliasesAliasIdDeleteResponse,
    V2DeploymentsIdAliasesGetResponse,
    V2DeploymentsIdAliasesPostRequest,
    V2DeploymentsIdAliasesPostResponse,
    V2DeploymentsIdOrUrlEventsGetResponse,
    V2DomainsDomainRecordsPostRequest,
    V2DomainsDomainRecordsPostResponse,
    V2DomainsDomainRecordsRecordIdDeleteResponse,
    V2FilesPostResponse,
    V2IntegrationsLogDrainsGetResponse,
    V2IntegrationsLogDrainsPostRequest,
    V2IntegrationsLogDrainsPostResponse,
    V2SecretsIdOrNameDeleteResponse,
    V2SecretsNamePatchRequest,
    V2SecretsNamePatchResponse,
    V2SecretsNamePostRequest,
    V2SecretsNamePostResponse,
    V2TeamsGetResponse,
    V2TeamsTeamIdMembersGetResponse,
    V2TeamsTeamIdPatchRequest,
    V2UserGetResponse,
    V3EventsGetResponse,
    V3SecretsGetResponse,
    V3SecretsIdOrNameGetResponse,
    V3UserTokensPostRequest,
    V3UserTokensPostResponse,
    V3UserTokensTokenIdDeleteResponse,
    V4AliasesGetResponse,
    V4AliasesIdOrAliasGetResponse,
    V4DomainsBuyPostRequest,
    V4DomainsBuyPostResponse,
    V4DomainsDomainRecordsGetResponse,
    V4DomainsPostRequest,
    V4DomainsPostResponse,
    V4DomainsPriceGetResponse,
    V4DomainsStatusGetResponse,
    V5DomainsDomainGetResponse,
    V5DomainsGetResponse,
    V5UserTokensGetResponse,
    V5UserTokensTokenIdGetResponse,
    V6DeploymentsGetResponse,
    V6DeploymentsIdFilesGetResponse,
    V6DomainsDomainConfigGetResponse,
    V6DomainsDomainDeleteResponse,
    V7CertsIdDeleteResponse,
    V7CertsIdGetResponse,
    V7CertsPostRequest,
    V7CertsPostResponse,
    V7CertsPutRequest,
    V7CertsPutResponse,
    V8ArtifactsEventsPostRequest,
    V8ArtifactsHashPutResponse,
    V8ArtifactsPostRequest,
    V8ArtifactsPostResponse,
    V8ArtifactsStatusGetResponse,
    V9ProjectsGetResponse,
    V9ProjectsIdOrNameDomainsDomainDeleteResponse,
    V9ProjectsIdOrNameDomainsDomainGetResponse,
    V9ProjectsIdOrNameDomainsDomainPatchRequest,
    V9ProjectsIdOrNameDomainsDomainPatchResponse,
    V9ProjectsIdOrNameDomainsDomainVerifyPostResponse,
    V9ProjectsIdOrNameDomainsGetResponse,
    V9ProjectsIdOrNameDomainsPostRequest,
    V9ProjectsIdOrNameDomainsPostResponse,
    V9ProjectsIdOrNameEnvGetResponse,
    V9ProjectsIdOrNameEnvIdDeleteResponse,
    V9ProjectsIdOrNameEnvIdPatchRequest,
    V9ProjectsIdOrNameEnvIdPatchResponse,
    V9ProjectsIdOrNameGetResponse,
    V9ProjectsIdOrNamePatchRequest,
    V9ProjectsIdOrNamePatchResponse,
    V9ProjectsPostRequest,
    V9ProjectsPostResponse,
    V10ProjectsIdOrNameEnvPostRequest,
    V10ProjectsIdOrNameEnvPostResponse,
    V10ProjectsIdOrNameEnvPostResponse2,
    V11DeploymentsDeploymentIdBuildsGetResponse,
    V12DeploymentsIdCancelPatchResponse,
    V13DeploymentsIdDeleteResponse,
    V13DeploymentsIdOrUrlGetResponse,
    V13DeploymentsPostRequest,
    V13DeploymentsPostResponse,
    Verified,
    View,
)

app = MCPProxy(
    contact={
        'email': 'support@vercel.com',
        'name': 'Vercel Support',
        'url': 'https://vercel.com/support',
    },
    description='Vercel combines the best developer experience with an obsessive focus on end-user performance. Our platform enables frontend teams to do their best work.',
    title='Vercel API',
    version='0.0.1',
    servers=[{'description': 'Production API', 'url': 'https://api.vercel.com'}],
)


@app.get(
    '/edge-config',
    description=""" Returns all Edge Configs. """,
    tags=['edge_config_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_edge_configs(team_id: Optional[str] = Query(None, alias='teamId')):
    """
    Get Edge Configs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/edge-config',
    description=""" Creates an Edge Config. """,
    tags=['edge_config_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_edge_config(
    team_id: Optional[str] = Query(None, alias='teamId'),
    body: EdgeConfigPostRequest = None,
):
    """
    Create an Edge Config
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/edge-config/{edgeConfigId}',
    description=""" Delete an Edge Config by id. """,
    tags=['edge_config_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_edge_config(
    edge_config_id: str = Path(..., alias='edgeConfigId'),
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    Delete an Edge Config
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/edge-config/{edgeConfigId}',
    description=""" Returns an Edge Config. """,
    tags=['edge_config_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_edge_config(
    edge_config_id: str = Path(..., alias='edgeConfigId'),
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    Get an Edge Config
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/edge-config/{edgeConfigId}',
    description=""" Updates an Edge Config. """,
    tags=['edge_config_management', 'team_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_edge_config(
    edge_config_id: str = Path(..., alias='edgeConfigId'),
    team_id: Optional[str] = Query(None, alias='teamId'),
    body: EdgeConfigEdgeConfigIdPutRequest = None,
):
    """
    Update an Edge Config
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/edge-config/{edgeConfigId}/item/{edgeConfigItemKey}',
    description=""" Returns a specific Edge Config Item. """,
    tags=['edge_config_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_edge_config_item(
    edge_config_id: str = Path(..., alias='edgeConfigId'),
    edge_config_item_key: str = Path(..., alias='edgeConfigItemKey'),
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    Get an Edge Config item
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/edge-config/{edgeConfigId}/items',
    description=""" Returns all items of an Edge Config. """,
    tags=['edge_config_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_edge_config_items(
    edge_config_id: str = Path(..., alias='edgeConfigId'),
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    Get Edge Config items
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/edge-config/{edgeConfigId}/items',
    description=""" Update multiple Edge Config Items in batch. """,
    tags=['edge_config_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def patcht_edge_config_items(
    edge_config_id: str = Path(..., alias='edgeConfigId'),
    team_id: Optional[str] = Query(None, alias='teamId'),
    body: EdgeConfigEdgeConfigIdItemsPatchRequest = None,
):
    """
    Update Edge Config items in batch
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/edge-config/{edgeConfigId}/token',
    description=""" Adds a token to an existing Edge Config. """,
    tags=['edge_config_management', 'auth_token_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_edge_config_token(
    edge_config_id: str = Path(..., alias='edgeConfigId'),
    team_id: Optional[str] = Query(None, alias='teamId'),
    body: EdgeConfigEdgeConfigIdTokenPostRequest = None,
):
    """
    Create an Edge Config token
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/edge-config/{edgeConfigId}/token/{token}',
    description=""" Return meta data about an Edge Config token. """,
    tags=['edge_config_management', 'auth_token_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_edge_config_token(
    edge_config_id: str = Path(..., alias='edgeConfigId'),
    token: str = ...,
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    Get Edge Config token meta data
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/edge-config/{edgeConfigId}/tokens',
    description=""" Deletes one or more tokens of an existing Edge Config. """,
    tags=['edge_config_management', 'integration_configuration'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_edge_config_tokens(
    edge_config_id: str = Path(..., alias='edgeConfigId'),
    team_id: Optional[str] = Query(None, alias='teamId'),
    body: EdgeConfigEdgeConfigIdTokensDeleteRequest = None,
):
    """
    Delete one or more Edge Config tokens
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/edge-config/{edgeConfigId}/tokens',
    description=""" Returns all tokens of an Edge Config. """,
    tags=['edge_config_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_edge_config_tokens(
    edge_config_id: str = Path(..., alias='edgeConfigId'),
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    Get all tokens of an Edge Config
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/registration',
    description=""" Request a new login for a user to get a token. This will respond with a verification token and send an email to confirm the request. Once confirmed you can use the verification token to get an authentication token. """,
    tags=['user_authentication', 'user_account_management'],
)
def email_login(body: RegistrationPostRequest = None):
    """
    Login with email
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/registration/verify',
    description=""" Verify the user accepted the login request and get a authentication token. The user email address and the token received after requesting the login must be added to the URL as a query string with the names `email` and `token`. """,
    tags=['user_authentication', 'auth_token_management'],
)
def verify_token(
    email: Optional[str] = None,
    token: str = ...,
    token_name: Optional[str] = Query(None, alias='tokenName'),
    sso_user_id: Optional[str] = Query(None, alias='ssoUserId'),
):
    """
    Verify a login request to get an authentication token
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/deployments/{deploymentId}/checks',
    description=""" List all of the checks created for a deployment. """,
    tags=['check_management', 'deployment_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_all_checks(
    deployment_id: str = Path(..., alias='deploymentId'),
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    Retrieve a list of all checks
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/deployments/{deploymentId}/checks',
    description=""" Creates a new check. This endpoint must be called with an OAuth2 or it will produce a 400 error. """,
    tags=['check_management', 'deployment_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_check(
    deployment_id: str = Path(..., alias='deploymentId'),
    team_id: Optional[str] = Query(None, alias='teamId'),
    body: V1DeploymentsDeploymentIdChecksPostRequest = None,
):
    """
    Creates a new Check
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/deployments/{deploymentId}/checks/{checkId}',
    description=""" Return a detailed response for a single check. """,
    tags=['check_management', 'deployment_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_check(
    deployment_id: str = Path(..., alias='deploymentId'),
    check_id: str = Path(..., alias='checkId'),
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    Get a single check
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/deployments/{deploymentId}/checks/{checkId}',
    description=""" Update an existing check. This endpoint must be called with an OAuth2 or it will produce a 400 error. """,
    tags=['check_management', 'deployment_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_check(
    deployment_id: str = Path(..., alias='deploymentId'),
    check_id: str = Path(..., alias='checkId'),
    team_id: Optional[str] = Query(None, alias='teamId'),
    body: V1DeploymentsDeploymentIdChecksCheckIdPatchRequest = None,
):
    """
    Update a check
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/deployments/{deploymentId}/checks/{checkId}/rerequest',
    description=""" Rerequest a selected check that has failed. """,
    tags=['check_management', 'deployment_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def rerequest_check(
    deployment_id: str = Path(..., alias='deploymentId'),
    check_id: str = Path(..., alias='checkId'),
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    Rerequest a check
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/domains/records/{recordId}',
    description=""" Updates an existing DNS record for a domain name. """,
    tags=['dns_record_management', 'dns_management', 'domain_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_record(
    record_id: str = Path(..., alias='recordId'),
    team_id: Optional[str] = Query(None, alias='teamId'),
    body: V1DomainsRecordsRecordIdPatchRequest = None,
):
    """
    Update an existing DNS record
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/integrations/configuration/{id}',
    description=""" Allows to remove the configuration with the `id` provided in the parameters. The configuration and all of its resources will be removed. This includes Webhooks, LogDrains and Project Env variables. """,
    tags=['integration_configuration'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_configuration(id: str, team_id: Optional[str] = Query(None, alias='teamId')):
    """
    Delete an integration configuration
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/integrations/configuration/{id}',
    description=""" Allows to retrieve a the configuration with the provided id in case it exists. The authenticated user or team must be the owner of the config in order to access it. """,
    tags=['integration_configuration', 'edge_config_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_configuration(id: str, team_id: Optional[str] = Query(None, alias='teamId')):
    """
    Retrieve an integration configuration
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/integrations/configurations',
    description=""" Allows to retrieve all configurations for an authenticated integration. When the `project` view is used, configurations generated for the authorization flow will be filtered out of the results. """,
    tags=['user_data_management', 'team_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_configurations(
    view: View, team_id: Optional[str] = Query(None, alias='teamId')
):
    """
    Get configurations for the authenticated user or team
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/integrations/git-namespaces',
    description=""" Lists git namespaces for a supported provider. Supported providers are `github`, `gitlab` and `bitbucket`. If the provider is not provided, it will try to obtain it from the user that authenticated the request. """,
    tags=['git_integration_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def git_namespaces(
    provider: Optional[Provider] = None,
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    List git namespaces by provider
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/integrations/log-drains/{id}',
    description=""" Deletes the Integration log drain with the provided `id`. When using an OAuth2 Token, the log drain can be deleted only if the integration owns it. """,
    tags=['log_drain_management', 'integration_log_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_integration_log_drain(
    id: str, team_id: Optional[str] = Query(None, alias='teamId')
):
    """
    Deletes the Integration log drain with the provided `id`
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/integrations/search-repo',
    description=""" Lists git repositories linked to a namespace `id` for a supported provider. A specific namespace `id` can be obtained via the `git-namespaces`  endpoint. Supported providers are `github`, `gitlab` and `bitbucket`. If the provider or namespace is not provided, it will try to obtain it from the user that authenticated the request. """,
    tags=['git_integration_management', 'integration_configuration'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_v1_integrations_search_repo(
    query: Optional[str] = None,
    namespace_id: Optional[Union[str, float]] = Query(None, alias='namespaceId'),
    provider: Optional[Provider] = None,
    installation_id: Optional[str] = Query(None, alias='installationId'),
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    List git repositories linked to namespace by provider
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/log-drains',
    description=""" Retrieves a list of Configurable Log Drains. This endpoint must be called with a team AccessToken (integration OAuth2 clients are not allowed). Only log drains owned by the authenticated team can be accessed. """,
    tags=['log_drain_management', 'integration_configuration'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_configurable_log_drains(
    project_id: Optional[constr(pattern=r'^[a-zA-z0-9_]+$')] = Query(
        None, alias='projectId'
    ),
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    Retrieves a list of Configurable Log Drains
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/log-drains',
    description=""" Creates a configurable log drain. This endpoint must be called with a team AccessToken (integration OAuth2 clients are not allowed) """,
    tags=['log_drain_management', 'integration_log_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_configurable_log_drain(
    team_id: Optional[str] = Query(None, alias='teamId'),
    body: V1LogDrainsPostRequest = None,
):
    """
    Creates a Configurable Log Drain
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/log-drains/{id}',
    description=""" Deletes a Configurable Log Drain. This endpoint must be called with a team AccessToken (integration OAuth2 clients are not allowed). Only log drains owned by the authenticated team can be deleted. """,
    tags=['log_drain_management', 'integration_configuration'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_configurable_log_drain(
    id: str, team_id: Optional[str] = Query(None, alias='teamId')
):
    """
    Deletes a Configurable Log Drain
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/log-drains/{id}',
    description=""" Retrieves a Configurable Log Drain. This endpoint must be called with a team AccessToken (integration OAuth2 clients are not allowed). Only log drains owned by the authenticated team can be accessed. """,
    tags=['log_drain_management', 'integration_log_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_configurable_log_drain(
    id: str, team_id: Optional[str] = Query(None, alias='teamId')
):
    """
    Retrieves a Configurable Log Drain
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/projects/{idOrName}/env/{id}',
    description=""" Retrieve the environment variable for a given project. """,
    tags=['environment_variable_management', 'project_env_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_project_env(
    id_or_name: str = Path(..., alias='idOrName'),
    id: str = ...,
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    Retrieve the decrypted value of an environment variable of a project by id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/teams',
    description=""" Create a new Team under your account. You need to send a POST request with the desired Team slug, and optionally the Team name. """,
    tags=['team_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_team(body: V1TeamsPostRequest = None):
    """
    Create a Team
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/teams/{teamId}',
    description=""" Delete a team under your account. You need to send a `DELETE` request with the desired team `id`. An optional array of reasons for deletion may also be sent. """,
    tags=['team_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_team(
    team_id: str = Path(..., alias='teamId'), body: V1TeamsTeamIdDeleteRequest = None
):
    """
    Delete a Team
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/teams/{teamId}/invites/{inviteId}',
    description=""" Delete an active Team invite code. """,
    tags=['team_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_team_invite_code(
    invite_id: str = Path(..., alias='inviteId'),
    team_id: str = Path(..., alias='teamId'),
):
    """
    Delete a Team invite code
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/teams/{teamId}/members',
    description=""" Invite a user to join the team specified in the URL. The authenticated user needs to be an `OWNER` in order to successfully invoke this endpoint. The user can be specified with an email or an ID. If both email and ID are provided, ID will take priority. """,
    tags=['user_account_management', 'team_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def invite_user_to_team(
    team_id: str = Path(..., alias='teamId'),
    body: V1TeamsTeamIdMembersPostRequest = None,
):
    """
    Invite a user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/teams/{teamId}/members/teams/join',
    description=""" Join a team with a provided invite code or team ID. """,
    tags=['team_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def join_team(
    team_id: str = Path(..., alias='teamId'),
    body: V1TeamsTeamIdMembersTeamsJoinPostRequest = None,
):
    """
    Join a team
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/teams/{teamId}/members/{uid}',
    description=""" Remove a Team Member from the Team, or dismiss a user that requested access, or leave a team. """,
    tags=['team_management', 'user_account_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def remove_team_member(uid: str, team_id: str = Path(..., alias='teamId')):
    """
    Remove a Team Member
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/teams/{teamId}/members/{uid}',
    description=""" Update the membership of a Team Member on the Team specified by `teamId`, such as changing the _role_ of the member, or confirming a request to join the Team for an unconfirmed member. The authenticated user must be an `OWNER` of the Team. """,
    tags=['team_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_team_member(
    uid: str,
    team_id: str = Path(..., alias='teamId'),
    body: V1TeamsTeamIdMembersUidPatchRequest = None,
):
    """
    Update a Team Member
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/teams/{teamId}/request',
    description=""" Request access to a team as a member. An owner has to approve the request. Only 10 users can request access to a team at the same time. """,
    tags=['team_management', 'user_account_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def request_access_to_team(
    team_id: str = Path(..., alias='teamId'),
    body: V1TeamsTeamIdRequestPostRequest = None,
):
    """
    Request access to a team
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/teams/{teamId}/request/{userId}',
    description=""" Check the status of a join request. It'll respond with a 404 if the request has been declined. If no `userId` path segment was provided, this endpoint will instead return the status of the authenticated user. """,
    tags=['user_account_management', 'user_data_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_team_access_request(
    user_id: str = Path(..., alias='userId'), team_id: str = Path(..., alias='teamId')
):
    """
    Get access request status
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/user',
    description=""" Initiates the deletion process for the currently authenticated User, by sending a deletion confirmation email. The email contains a link that the user needs to visit in order to proceed with the deletion process. """,
    tags=['user_account_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def request_delete(body: V1UserDeleteRequest = None):
    """
    Delete User Account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/webhooks',
    description=""" Get a list of webhooks """,
    tags=['webhook_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_webhooks(
    project_id: Optional[constr(pattern=r'^[a-zA-z0-9_]+$')] = Query(
        None, alias='projectId'
    ),
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    Get a list of webhooks
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/webhooks',
    description=""" Creates a webhook """,
    tags=['webhook_operations', 'team_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_webhook(
    team_id: Optional[str] = Query(None, alias='teamId'),
    body: V1WebhooksPostRequest = None,
):
    """
    Creates a webhook
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/webhooks/{id}',
    description=""" Deletes a webhook """,
    tags=['webhook_operations', 'integration_configuration'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_webhook(id: str, team_id: Optional[str] = Query(None, alias='teamId')):
    """
    Deletes a webhook
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/webhooks/{id}',
    description=""" Get a webhook """,
    tags=['webhook_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_webhook(id: str, team_id: Optional[str] = Query(None, alias='teamId')):
    """
    Get a webhook
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v10/projects/{idOrName}/env',
    description=""" Create one ore more environment variables for a project by passing its `key`, `value`, `type` and `target` and by specifying the project by either passing the project `id` or `name` in the URL. """,
    tags=['environment_variable_management', 'project_env_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_project_env(
    id_or_name: str = Path(..., alias='idOrName'),
    team_id: Optional[str] = Query(None, alias='teamId'),
    body: V10ProjectsIdOrNameEnvPostRequest = None,
):
    """
    Create one or more environment variables
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v11/deployments/{deploymentId}/builds',
    description=""" Retrieves the list of builds given their deployment's unique identifier. """,
    tags=['deployment_management', 'check_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_deployment_builds(
    deployment_id: str = Path(..., alias='deploymentId'),
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    List Deployment Builds
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v12/deployments/{id}/cancel',
    description=""" This endpoint allows you to cancel a deployment which is currently building, by supplying its `id` in the URL. """,
    tags=['deployment_management', 'check_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def cancel_deployment(id: str, team_id: Optional[str] = Query(None, alias='teamId')):
    """
    Cancel a deployment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v13/deployments',
    description=""" Create a new deployment with all the required and intended data. If the deployment is not a git deployment, all files must be provided with the request, either referenced or inlined. Additionally, a deployment id can be specified to redeploy a previous deployment. """,
    tags=['deployment_management', 'project_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_deployment(
    force_new: Optional[ForceNew] = Query(None, alias='forceNew'),
    skip_auto_detection_confirmation: Optional[SkipAutoDetectionConfirmation] = Query(
        None, alias='skipAutoDetectionConfirmation'
    ),
    team_id: Optional[str] = Query(None, alias='teamId'),
    body: V13DeploymentsPostRequest = None,
):
    """
    Create a new deployment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v13/deployments/{idOrUrl}',
    description=""" Retrieves information for a deployment either by supplying its ID (`id` property) or Hostname (`url` property). Additional details will be included when the authenticated user is an owner of the deployment. """,
    tags=['deployment_management', 'check_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_deployment(
    id_or_url: str = Path(..., alias='idOrUrl'),
    with_git_repo_info: Optional[str] = Query(None, alias='withGitRepoInfo'),
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    Get a deployment by ID or URL
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v13/deployments/{id}',
    description=""" This API allows you to delete a deployment, either by supplying its `id` in the URL or the `url` of the deployment as a query parameter. You can obtain the ID, for example, by listing all deployments. """,
    tags=['deployment_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_deployment(
    id: str,
    url: Optional[str] = None,
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    Delete a Deployment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v2/aliases/{aliasId}',
    description=""" Delete an Alias with the specified ID. """,
    tags=['alias_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_alias(
    alias_id: AliasId = Path(..., alias='aliasId'),
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    Delete an Alias
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/deployments/{idOrUrl}/events',
    description=""" Get the build logs of a deployment by deployment ID and build ID. It can work as an infinite stream of logs or as a JSON endpoint depending on the input parameters. """,
    tags=['deployment_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_deployment_events(
    id_or_url: str = Path(..., alias='idOrUrl'),
    direction: Optional[Direction] = 'forward',
    follow: Optional[Follow] = None,
    limit: Optional[float] = None,
    name: Optional[str] = None,
    since: Optional[float] = None,
    until: Optional[float] = None,
    status_code: Optional[StatusCode] = Query(None, alias='statusCode'),
    delimiter: Optional[Delimiter] = None,
    builds: Optional[Builds1] = None,
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    Get deployment events
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/deployments/{id}/aliases',
    description=""" Retrieves all Aliases for the Deployment with the given ID. The authenticated User must own the deployment. """,
    tags=['deployment_management', 'alias_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_deployment_aliases(
    id: str, team_id: Optional[str] = Query(None, alias='teamId')
):
    """
    List Deployment Aliases
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/deployments/{id}/aliases',
    description=""" Creates a new alias for the deployment with the given deployment ID. The authenticated user must own this deployment. If the desired alias is already assigned to another deployment, then it will be removed from the old deployment and assigned to the new one. """,
    tags=['alias_management', 'team_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def assign_alias(
    id: Id,
    team_id: Optional[str] = Query(None, alias='teamId'),
    body: V2DeploymentsIdAliasesPostRequest = None,
):
    """
    Assign an Alias
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/domains/{domain}/records',
    description=""" Creates a DNS record for a domain. """,
    tags=['dns_record_management', 'dns_management', 'domain_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_record(
    domain: str,
    team_id: Optional[str] = Query(None, alias='teamId'),
    body: V2DomainsDomainRecordsPostRequest = None,
):
    """
    Create a DNS record
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v2/domains/{domain}/records/{recordId}',
    description=""" Removes an existing DNS record from a domain name. """,
    tags=['dns_record_management', 'dns_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def remove_record(
    domain: str,
    record_id: str = Path(..., alias='recordId'),
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    Delete a DNS record
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/files',
    description=""" Before you create a deployment you need to upload the required files for that deployment. To do it, you need to first upload each file to this endpoint. Once that's completed, you can create a new deployment with the uploaded files. The file content must be placed inside the body of the request. In the case of a successful response you'll receive a status code 200 with an empty body. """,
    tags=['file_upload_management', 'deployment_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def upload_file(
    content__length: Optional[float] = Header(None, alias='Content-Length'),
    x_vercel_digest: Optional[constr(max_length=40)] = Header(
        None, alias='x-vercel-digest'
    ),
    x_now_digest: Optional[constr(max_length=40)] = Header(None, alias='x-now-digest'),
    x_now_size: Optional[float] = Header(None, alias='x-now-size'),
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    Upload Deployment Files
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/integrations/log-drains',
    description=""" Retrieves a list of all Integration log drains that are defined for the authorized account. When using an OAuth2 token, the list is limited to log drains created by the authenticated integration. """,
    tags=['integration_log_management', 'log_drain_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_integration_log_drains(team_id: Optional[str] = Query(None, alias='teamId')):
    """
    Retrieves a list of Integration log drains
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/integrations/log-drains',
    description=""" Creates an Integration log drain. This endpoint must be called with an OAuth2 client (integration), since log drains are tied to integrations. If it is called with a different token type it will produce a 400 error. """,
    tags=[
        'integration_log_management',
        'integration_configuration',
        'log_drain_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_log_drain(
    team_id: Optional[str] = Query(None, alias='teamId'),
    body: V2IntegrationsLogDrainsPostRequest = None,
):
    """
    Creates a new Integration Log Drain
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v2/secrets/{idOrName}',
    description=""" This deletes the user's secret defined in the URL. """,
    tags=['secret_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_secret(
    id_or_name: str = Path(..., alias='idOrName'),
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    Delete a secret
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v2/secrets/{name}',
    description=""" Enables to edit the name of a user's secret. The name has to be unique to that user's secrets. """,
    tags=['secret_management', 'team_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def rename_secret(
    name: str,
    team_id: Optional[str] = Query(None, alias='teamId'),
    body: V2SecretsNamePatchRequest = None,
):
    """
    Change secret name
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/secrets/{name}',
    description=""" Allows to create a new secret. """,
    tags=['secret_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_secret(
    team_id: Optional[str] = Query(None, alias='teamId'),
    name: str = ...,
    body: V2SecretsNamePostRequest = None,
):
    """
    Create a new secret
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/teams',
    description=""" Get a paginated list of all the Teams the authenticated User is a member of. """,
    tags=['team_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_teams(
    limit: Optional[float] = None,
    since: Optional[float] = None,
    until: Optional[float] = None,
):
    """
    List all teams
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/teams/{teamId}',
    description=""" Get information for the Team specified by the `teamId` parameter. """,
    tags=['team_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_team(slug: Optional[str] = None, team_id: str = Path(..., alias='teamId')):
    """
    Get a Team
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v2/teams/{teamId}',
    description=""" Update the information of a Team specified by the `teamId` parameter. The request body should contain the information that will be updated on the Team. """,
    tags=['team_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def patch_team(
    team_id: str = Path(..., alias='teamId'), body: V2TeamsTeamIdPatchRequest = None
):
    """
    Update a Team
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/teams/{teamId}/members',
    description=""" Get a paginated list of team members for the provided team. """,
    tags=['team_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_team_members(
    limit: Optional[float] = None,
    since: Optional[float] = None,
    until: Optional[float] = None,
    search: Optional[str] = None,
    role: Optional[Role5] = None,
    exclude_project: Optional[str] = Query(None, alias='excludeProject'),
    team_id: str = Path(..., alias='teamId'),
):
    """
    List team members
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/user',
    description=""" Retrieves information related to the currently authenticated User. """,
    tags=['user_data_management', 'user_account_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_auth_user():
    """
    Get the User
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v3/events',
    description=""" Retrieves a list of "events" generated by the User on Vercel. Events are generated when the User performs a particular action, such as logging in, creating a deployment, and joining a Team (just to name a few). When the `teamId` parameter is supplied, then the events that are returned will be in relation to the Team that was specified. """,
    tags=['user_data_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_user_events(
    limit: Optional[float] = None,
    since: Optional[str] = None,
    until: Optional[str] = None,
    types: Optional[str] = None,
    user_id: Optional[str] = Query(None, alias='userId'),
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    List User Events
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v3/secrets',
    description=""" Retrieves the active Vercel secrets for the authenticated user. By default it returns 20 secrets. The rest can be retrieved using the pagination options. The body will contain an entry for each secret. """,
    tags=['secret_management', 'project_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_secrets(
    id: Optional[str] = None,
    project_id: Optional[str] = Query(None, alias='projectId'),
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    List secrets
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v3/secrets/{idOrName}',
    description=""" Retrieves the information for a specific secret by passing either the secret id or name in the URL. """,
    tags=['secret_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_secret(
    id_or_name: str = Path(..., alias='idOrName'),
    decrypt: Optional[Decrypt] = None,
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    Get a single secret
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v3/user/tokens',
    description=""" Creates and returns a new authentication token for the currently authenticated User. The `bearerToken` property is only provided once, in the response body, so be sure to save it on the client for use with API requests. """,
    tags=['user_authentication', 'auth_token_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_auth_token(
    team_id: Optional[str] = Query(None, alias='teamId'),
    body: V3UserTokensPostRequest = None,
):
    """
    Create an Auth Token
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v3/user/tokens/{tokenId}',
    description=""" Invalidate an authentication token, such that it will no longer be valid for future HTTP requests. """,
    tags=['auth_token_management', 'user_authentication'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_auth_token(token_id: str = Path(..., alias='tokenId')):
    """
    Delete an authentication token
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v4/aliases',
    description=""" Retrieves a list of aliases for the authenticated User or Team. When `domain` is provided, only aliases for that domain will be returned. When `projectId` is provided, it will only return the given project aliases. """,
    tags=['alias_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_aliases(
    domain: Optional[Domain] = None,
    from_: Optional[float] = Query(None, alias='from'),
    limit: Optional[float] = None,
    project_id: Optional[str] = Query(None, alias='projectId'),
    since: Optional[float] = None,
    until: Optional[float] = None,
    rollback_deployment_id: Optional[str] = Query(None, alias='rollbackDeploymentId'),
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    List aliases
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v4/aliases/{idOrAlias}',
    description=""" Retrieves an Alias for the given host name or alias ID. """,
    tags=['alias_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_alias(
    from_: Optional[float] = Query(None, alias='from'),
    id_or_alias: str = Path(..., alias='idOrAlias'),
    project_id: Optional[str] = Query(None, alias='projectId'),
    since: Optional[float] = None,
    until: Optional[float] = None,
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    Get an Alias
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v4/domains',
    description=""" This endpoint is used for registering a new domain name with Vercel for the authenticating user, and also for initiating a domain transfer request from an external Registrar to Vercel. """,
    tags=['domain_management', 'project_domain_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_or_transfer_domain(
    team_id: Optional[str] = Query(None, alias='teamId'),
    body: V4DomainsPostRequest = None,
):
    """
    Register or transfer-in a new Domain
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v4/domains/buy',
    description=""" Allows to purchase the specified domain. """,
    tags=['domain_management', 'project_domain_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def buy_domain(
    team_id: Optional[str] = Query(None, alias='teamId'),
    body: V4DomainsBuyPostRequest = None,
):
    """
    Purchase a domain
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v4/domains/price',
    description=""" Check the price to purchase a domain and how long a single purchase period is. """,
    tags=['domain_management', 'project_domain_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def check_domain_price(
    name: str,
    type: Optional[Type138] = None,
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    Check the price for a domain
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v4/domains/status',
    description=""" Check if a domain name is available for purchase. """,
    tags=['domain_management', 'project_domain_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def check_domain_status(
    name: str, team_id: Optional[str] = Query(None, alias='teamId')
):
    """
    Check a Domain Availability
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v4/domains/{domain}/records',
    description=""" Retrieves a list of DNS records created for a domain name. By default it returns 20 records if no limit is provided. The rest can be retrieved using the pagination options. """,
    tags=['dns_management', 'dns_record_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_records(
    domain: str,
    limit: Optional[str] = None,
    since: Optional[str] = None,
    until: Optional[str] = None,
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    List existing DNS records
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v5/domains',
    description=""" Retrieves a list of domains registered for the authenticating user. By default it returns the last 20 domains if no limit is provided. """,
    tags=['domain_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_domains(
    limit: Optional[float] = None,
    since: Optional[float] = None,
    until: Optional[float] = None,
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    List all the domains
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v5/domains/{domain}',
    description=""" Get information for a single domain in an account or team. """,
    tags=['domain_management', 'project_domain_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_domain(domain: str, team_id: Optional[str] = Query(None, alias='teamId')):
    """
    Get Information for a Single Domain
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v5/user/tokens',
    description=""" Retrieve a list of the current User's authentication tokens. """,
    tags=['auth_token_management', 'user_authentication'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_auth_tokens():
    """
    List Auth Tokens
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v5/user/tokens/{tokenId}',
    description=""" Retrieve metadata about an authentication token belonging to the currently authenticated User. """,
    tags=['user_authentication', 'auth_token_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_auth_token(token_id: str = Path(..., alias='tokenId')):
    """
    Get Auth Token Metadata
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v6/deployments',
    description=""" List deployments under the account corresponding to the API token. If a deployment hasn't finished uploading (is incomplete), the `url` property will have a value of `null`. """,
    tags=['deployment_management', 'project_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_deployments(
    app: Optional[str] = None,
    from_: Optional[float] = Query(None, alias='from'),
    limit: Optional[float] = None,
    project_id: Optional[str] = Query(None, alias='projectId'),
    target: Optional[Target13] = None,
    to: Optional[float] = None,
    users: Optional[str] = None,
    since: Optional[float] = None,
    until: Optional[float] = None,
    state: Optional[str] = None,
    rollback_candidate: Optional[bool] = Query(None, alias='rollbackCandidate'),
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    List deployments
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v6/deployments/{id}/files',
    description=""" Allows to retrieve the file structure of a deployment by supplying the deployment unique identifier. """,
    tags=['deployment_management', 'file_upload_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_deployment_files(
    id: str, team_id: Optional[str] = Query(None, alias='teamId')
):
    """
    List Deployment Files
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v6/deployments/{id}/files/{fileId}',
    description=""" Allows to retrieve the content of a file by supplying the file identifier and the deployment unique identifier. The response body will contain the raw content of the file. """,
    tags=['deployment_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_deployment_file_contents(
    id: str,
    file_id: str = Path(..., alias='fileId'),
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    Get Deployment File Contents
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v6/domains/{domain}',
    description=""" Delete a previously registered domain name from Vercel. Deleting a domain will automatically remove any associated aliases. """,
    tags=['domain_management', 'project_domain_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_domain(domain: str, team_id: Optional[str] = Query(None, alias='teamId')):
    """
    Remove a domain by name
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v6/domains/{domain}/config',
    description=""" Get a Domain's configuration. """,
    tags=['domain_management', 'dns_management', 'project_domain_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_domain_config(
    domain: str, team_id: Optional[str] = Query(None, alias='teamId')
):
    """
    Get a Domain's configuration
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v7/certs',
    description=""" Issue a new cert """,
    tags=['certificate_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def issue_cert(
    team_id: Optional[str] = Query(None, alias='teamId'),
    body: V7CertsPostRequest = None,
):
    """
    Issue a new cert
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v7/certs',
    description=""" Upload a cert """,
    tags=['certificate_management', 'file_upload_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def upload_cert(
    team_id: Optional[str] = Query(None, alias='teamId'), body: V7CertsPutRequest = None
):
    """
    Upload a cert
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v7/certs/{id}',
    description=""" Remove cert """,
    tags=['certificate_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def remove_cert(id: str, team_id: Optional[str] = Query(None, alias='teamId')):
    """
    Remove cert
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v7/certs/{id}',
    description=""" Get cert by id """,
    tags=['certificate_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_cert_by_id(id: str, team_id: Optional[str] = Query(None, alias='teamId')):
    """
    Get cert by id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v8/artifacts',
    description=""" Query information about an array of artifacts. """,
    tags=['artifact_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def artifact_query(
    team_id: Optional[str] = Query(None, alias='teamId'),
    body: V8ArtifactsPostRequest = None,
):
    """
    Query information about an artifact
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v8/artifacts/events',
    description=""" Records an artifacts cache usage event. The body of this request is an array of cache usage events. The supported event types are `HIT` and `MISS`. The source is either `LOCAL` the cache event was on the users filesystem cache or `REMOTE` if the cache event is for a remote cache. When the event is a `HIT` the request also accepts a number `duration` which is the time taken to generate the artifact in the cache. """,
    tags=['artifact_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def record_events(
    x_artifact_client_ci: Optional[constr(max_length=50)] = Header(
        None, alias='x-artifact-client-ci'
    ),
    x_artifact_client_interactive: Optional[conint(ge=0, le=1)] = Header(
        None, alias='x-artifact-client-interactive'
    ),
    team_id: Optional[str] = Query(None, alias='teamId'),
    body: V8ArtifactsEventsPostRequest = None,
):
    """
    Record an artifacts cache usage event
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v8/artifacts/status',
    description=""" Check the status of Remote Caching for this principal. Returns a JSON-encoded status indicating if Remote Caching is enabled, disabled, or disabled due to usage limits. """,
    tags=['artifact_management', 'project_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def status(team_id: Optional[str] = Query(None, alias='teamId')):
    """
    Get status of Remote Caching for this principal
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v8/artifacts/{hash}',
    description=""" Downloads a cache artifact indentified by its `hash` specified on the request path. The artifact is downloaded as an octet-stream. The client should verify the content-length header and response body. """,
    tags=['artifact_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def download_artifact(
    x_artifact_client_ci: Optional[constr(max_length=50)] = Header(
        None, alias='x-artifact-client-ci'
    ),
    x_artifact_client_interactive: Optional[conint(ge=0, le=1)] = Header(
        None, alias='x-artifact-client-interactive'
    ),
    hash: str = ...,
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    Download a cache artifact
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.head(
    '/v8/artifacts/{hash}',
    description=""" Check that a cache artifact with the given `hash` exists. This request returns response headers only and is equivalent to a `GET` request to this endpoint where the response contains no body. """,
    tags=['artifact_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def artifact_exists(hash: str, team_id: Optional[str] = Query(None, alias='teamId')):
    """
    Check if a cache artifact exists
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v8/artifacts/{hash}',
    description=""" Uploads a cache artifact identified by the `hash` specified on the path. The cache artifact can then be downloaded with the provided `hash`. """,
    tags=['artifact_management', 'file_upload_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def upload_artifact(
    content__length: float = Header(..., alias='Content-Length'),
    x_artifact_duration: Optional[float] = Header(None, alias='x-artifact-duration'),
    x_artifact_client_ci: Optional[constr(max_length=50)] = Header(
        None, alias='x-artifact-client-ci'
    ),
    x_artifact_client_interactive: Optional[conint(ge=0, le=1)] = Header(
        None, alias='x-artifact-client-interactive'
    ),
    x_artifact_tag: Optional[constr(max_length=600)] = Header(
        None, alias='x-artifact-tag'
    ),
    hash: str = ...,
    team_id: Optional[str] = Query(None, alias='teamId'),
    request: Request = ...,
):
    """
    Upload a cache artifact
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v9/projects',
    description=""" Allows to retrieve the list of projects of the authenticated user. The list will be paginated and the provided query parameters allow filtering the returned projects. """,
    tags=['project_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_projects(
    from_: Optional[str] = Query(None, alias='from'),
    git_fork_protection: Optional[GitForkProtection] = Query(
        None, alias='gitForkProtection'
    ),
    limit: Optional[str] = None,
    search: Optional[str] = None,
    repo: Optional[str] = None,
    repo_id: Optional[str] = Query(None, alias='repoId'),
    repo_url: Optional[str] = Query(None, alias='repoUrl'),
    exclude_repos: Optional[str] = Query(None, alias='excludeRepos'),
    edge_config_id: Optional[str] = Query(None, alias='edgeConfigId'),
    edge_config_token_id: Optional[str] = Query(None, alias='edgeConfigTokenId'),
    connect_configuration_id: Optional[str] = Query(
        None, alias='connectConfigurationId'
    ),
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    Retrieve a list of projects
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v9/projects',
    description=""" Allows to create a new project with the provided configuration. It only requires the project `name` but more configuration can be provided to override the defaults. """,
    tags=['project_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_project(
    team_id: Optional[str] = Query(None, alias='teamId'),
    body: V9ProjectsPostRequest = None,
):
    """
    Create a new project
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v9/projects/{idOrName}',
    description=""" Delete a specific project by passing either the project `id` or `name` in the URL. """,
    tags=['project_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_project(
    id_or_name: str = Path(..., alias='idOrName'),
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    Delete a Project
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v9/projects/{idOrName}',
    description=""" Get the information for a specific project by passing either the project `id` or `name` in the URL. """,
    tags=['project_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_project(
    id_or_name: IdOrName = Path(..., alias='idOrName'),
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    Find a project by id or name
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v9/projects/{idOrName}',
    description=""" Update the fields of a project using either its `name` or `id`. """,
    tags=['project_management', 'team_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_project(
    id_or_name: str = Path(..., alias='idOrName'),
    team_id: Optional[str] = Query(None, alias='teamId'),
    body: V9ProjectsIdOrNamePatchRequest = None,
):
    """
    Update an existing project
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v9/projects/{idOrName}/domains',
    description=""" Retrieve the domains associated with a given project by passing either the project `id` or `name` in the URL. """,
    tags=['project_domain_management', 'project_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_project_domains(
    id_or_name: IdOrName1 = Path(..., alias='idOrName'),
    production: Optional[Production] = 'false',
    git_branch: Optional[str] = Query(None, alias='gitBranch'),
    redirects: Optional[Redirects] = 'true',
    redirect: Optional[str] = None,
    verified: Optional[Verified] = None,
    limit: Optional[float] = None,
    since: Optional[float] = None,
    until: Optional[float] = None,
    order: Optional[Order] = 'DESC',
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    Retrieve project domains by project by id or name
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v9/projects/{idOrName}/domains',
    description=""" Add a domain to the project by passing its domain name and by specifying the project by either passing the project `id` or `name` in the URL. If the domain is not yet verified to be used on this project, the request will return `verified = false`, and the domain will need to be verified according to the `verification` challenge via `POST /projects/:idOrName/domains/:domain/verify`. If the domain already exists on the project, the request will fail with a `400` status code. """,
    tags=['domain_management', 'project_domain_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def add_project_domain(
    id_or_name: str = Path(..., alias='idOrName'),
    team_id: Optional[str] = Query(None, alias='teamId'),
    body: V9ProjectsIdOrNameDomainsPostRequest = None,
):
    """
    Add a domain to a project
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v9/projects/{idOrName}/domains/{domain}',
    description=""" Remove a domain from a project by passing the domain name and by specifying the project by either passing the project `id` or `name` in the URL. """,
    tags=['domain_management', 'project_domain_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def remove_project_domain(
    id_or_name: str = Path(..., alias='idOrName'),
    domain: str = ...,
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    Remove a domain from a project
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v9/projects/{idOrName}/domains/{domain}',
    description=""" Get project domain by project id/name and domain name. """,
    tags=['project_domain_management', 'project_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_project_domain(
    id_or_name: str = Path(..., alias='idOrName'),
    domain: str = ...,
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    Get a project domain
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v9/projects/{idOrName}/domains/{domain}',
    description=""" Update a project domain's configuration, including the name, git branch and redirect of the domain. """,
    tags=['project_domain_management', 'project_management', 'domain_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_project_domain(
    id_or_name: str = Path(..., alias='idOrName'),
    domain: str = ...,
    team_id: Optional[str] = Query(None, alias='teamId'),
    body: V9ProjectsIdOrNameDomainsDomainPatchRequest = None,
):
    """
    Update a project domain
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v9/projects/{idOrName}/domains/{domain}/verify',
    description=""" Attempts to verify a project domain with `verified = false` by checking the correctness of the project domain's `verification` challenge. """,
    tags=['project_domain_management', 'domain_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def verify_project_domain(
    id_or_name: str = Path(..., alias='idOrName'),
    domain: str = ...,
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    Verify project domain
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v9/projects/{idOrName}/env',
    description=""" Retrieve the environment variables for a given project by passing either the project `id` or `name` in the URL. """,
    tags=['environment_variable_management', 'project_env_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def filter_project_envs(
    id_or_name: str = Path(..., alias='idOrName'),
    git_branch: Optional[constr(max_length=250)] = Query(None, alias='gitBranch'),
    decrypt: Optional[Decrypt] = None,
    source: Optional[str] = None,
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    Retrieve the environment variables of a project by id or name
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v9/projects/{idOrName}/env/{id}',
    description=""" Delete a specific environment variable for a given project by passing the environment variable identifier and either passing the project `id` or `name` in the URL. """,
    tags=['environment_variable_management', 'project_env_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def remove_project_env(
    id_or_name: str = Path(..., alias='idOrName'),
    id: str = ...,
    team_id: Optional[str] = Query(None, alias='teamId'),
):
    """
    Remove an environment variable
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v9/projects/{idOrName}/env/{id}',
    description=""" Edit a specific environment variable for a given project by passing the environment variable identifier and either passing the project `id` or `name` in the URL. """,
    tags=['environment_variable_management', 'project_env_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def edit_project_env(
    id_or_name: str = Path(..., alias='idOrName'),
    id: str = ...,
    team_id: Optional[str] = Query(None, alias='teamId'),
    body: V9ProjectsIdOrNameEnvIdPatchRequest = None,
):
    """
    Edit an environment variable
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
